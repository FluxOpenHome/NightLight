# Custom LED Effects for Flux Night Light
# Included as a package in flux-night-light.yaml
# Effects are merged with the built-in effects via ESPHome package concatenation
# All effects use addressable_lambda for ESP-IDF compatibility
#
# Hardware: 4x4 snake-wired LED grid
#   Row 4 (top):  16 15 14 13   indices 15,14,13,12   (right to left)
#   Row 3:         9 10 11 12   indices  8, 9,10,11   (left to right)
#   Row 2:         8  7  6  5   indices  7, 6, 5, 4   (right to left)
#   Row 1 (bot):   1  2  3  4   indices  0, 1, 2, 3   (left to right)
#
# Grid mapping: grid[row][col] gives the LED index (0-based)
#   Row 0 (bottom): 0, 1, 2, 3
#   Row 1:          7, 6, 5, 4
#   Row 2:          8, 9,10,11
#   Row 3 (top):   15,14,13,12

light:
  - id: !extend led_array
    effects:
      - addressable_lambda:
          name: "Fire"
          update_interval: 30ms
          lambda: |-
            // Fire effect mapped to 4x4 snake grid
            // Heat rises from bottom row to top row properly
            auto rng = [](int mn, int mx) -> int {
              return mn + (int)(esp_random() % (uint32_t)(mx - mn));
            };

            // Grid map: grid[row][col] = LED index
            static const int grid[4][4] = {
              { 0,  1,  2,  3},   // Row 0 (bottom)
              { 7,  6,  5,  4},   // Row 1
              { 8,  9, 10, 11},   // Row 2
              {15, 14, 13, 12}    // Row 3 (top)
            };

            // Heat per column (4 columns, 4 rows each)
            static uint8_t heat[4][4] = {};

            for (int col = 0; col < 4; col++) {
              // Cool down each cell in this column
              for (int row = 0; row < 4; row++) {
                int cooldown = rng(0, 50);
                heat[col][row] = (cooldown >= heat[col][row]) ? 0 : heat[col][row] - cooldown;
              }

              // Heat drifts upward within the column
              for (int row = 3; row >= 1; row--) {
                heat[col][row] = (heat[col][row - 1] + heat[col][row]) / 2;
              }

              // Random sparks at the bottom of each column
              if (rng(0, 255) < 160) {
                int val = heat[col][0] + rng(160, 255);
                heat[col][0] = (val > 255) ? 255 : val;
              }

              // Map heat to color and set LEDs
              for (int row = 0; row < 4; row++) {
                uint8_t t = heat[col][row];
                uint8_t r = 0, g = 0, b = 0;
                if (t > 0) {
                  if (t <= 85) {
                    r = t * 3;
                  } else if (t <= 170) {
                    r = 255;
                    g = (t - 85) * 3;
                  } else {
                    r = 255;
                    g = 255;
                    b = (t - 170) * 3;
                  }
                }
                it[grid[row][col]] = Color(r, g, b);
              }
            }

      - addressable_lambda:
          name: "Flux Logo"
          update_interval: 50ms
          lambda: |-
            // Flux logo on 4x4 snake grid
            // LED layout (snake pattern):
            //   Row 4: 16 15 14 13   (right to left)
            //   Row 3:  9 10 11 12   (left to right)
            //   Row 2:  8  7  6  5   (right to left)
            //   Row 1:  1  2  3  4   (left to right)
            // Logo pixels (1-indexed): 1, 2, 4, 6, 7, 10, 11, 13, 16
            static const int logo[] = {0, 1, 3, 5, 6, 9, 10, 12, 15};
            static const int logo_size = 9;
            static int step = 0;
            static bool drawing = true;

            it.all() = Color(0, 0, 0);

            if (drawing) {
              int show = std::min(step + 1, logo_size);
              for (int i = 0; i < show; i++) {
                it[logo[i]] = current_color;
              }
              step++;
              if (step >= logo_size + 30) {
                drawing = false;
                step = 0;
              }
            } else {
              float fade = 1.0 - ((float)step / 20.0);
              if (fade < 0) fade = 0;
              for (int i = 0; i < logo_size; i++) {
                it[logo[i]] = Color(
                  current_color.r * fade,
                  current_color.g * fade,
                  current_color.b * fade
                );
              }
              step++;
              if (step >= 25) {
                drawing = true;
                step = 0;
              }
            }

      - addressable_lambda:
          name: "Gold Glitter"
          update_interval: 18ms
          lambda: |-
            // Gold base with random white sparkles
            static int sparkle_timer = 0;
            static int sparkle_led = -1;

            // Set all LEDs to gold
            for (int i = 0; i < it.size(); i++) {
              it[i] = Color(218, 165, 32);
            }

            // Add random white sparkle
            if (sparkle_timer == 0) {
              sparkle_led = esp_random() % it.size();
              it[sparkle_led] = Color(255, 255, 255);
              sparkle_timer = 1;
            } else {
              sparkle_timer++;
              if (sparkle_timer >= 10) {
                sparkle_timer = 0;
              }
            }

      - addressable_lambda:
          name: "Lightning Storm"
          update_interval: 5ms
          lambda: |-
            // Blue ambient glow with random lightning flashes
            static float speed_multiplier = 0.003;
            static uint32_t lightning_end = 0;
            static uint32_t lightning_wait = 0;
            static uint32_t lightning_modifier = 0;

            for (int led_index = 0; led_index < it.size(); led_index++) {
              uint32_t elapsed = millis() + (uint32_t)(led_index * 650);

              uint8_t b = (uint8_t)((pow(sin((elapsed * speed_multiplier) / 4.0), 3.0) + 1.0) * 80.0 + 90.0);
              uint8_t r, g;

              if (lightning_end == 0) {
                // Normal ambient blue glow
                r = (uint8_t)((sin((elapsed * speed_multiplier) / 5.0) + 1.0) * 40.0);
                g = (uint8_t)(pow(sin(((elapsed * speed_multiplier) / 8.0) + 3.14159 / 2.0), 4.0) * 50.0);

                if (millis() >= lightning_wait && (esp_random() % 1500) == 1) {
                  lightning_end = millis() + (esp_random() % 400 + 100);
                  lightning_modifier = esp_random() % 15 + 20;
                }
              } else {
                // Lightning flash
                r = g = (uint8_t)((sin((float)elapsed / lightning_modifier) + 1.0) * 60);

                if (millis() >= lightning_end) {
                  lightning_end = 0;
                  lightning_wait = millis() + 3000;
                }
              }

              it[led_index] = Color(r, g, b);
            }

      - addressable_lambda:
          name: "Sunrise"
          update_interval: 100ms
          lambda: |-
            // Gentle warm-up expanding from physical center of 4x4 grid
            // Transitions red -> orange -> warm white over ~5 minutes
            // Grid map: grid[row][col] = LED index
            static const int grid[4][4] = {
              { 0,  1,  2,  3},
              { 7,  6,  5,  4},
              { 8,  9, 10, 11},
              {15, 14, 13, 12}
            };

            static uint32_t start_time = 0;
            static bool started = false;
            const float duration = 300000.0f;  // 5 minutes in ms

            if (!started) {
              start_time = millis();
              started = true;
            }

            uint32_t elapsed = millis() - start_time;
            float progress = (float)elapsed / duration;
            if (progress > 1.0f) progress = 1.0f;

            // Physical center of 4x4 grid is at (1.5, 1.5)
            const float center_row = 1.5f;
            const float center_col = 1.5f;
            // Max distance from center to corner
            const float max_dist = 2.12f;  // sqrt(1.5^2 + 1.5^2)

            for (int row = 0; row < 4; row++) {
              for (int col = 0; col < 4; col++) {
                float dist = sqrtf((row - center_row) * (row - center_row) +
                                   (col - center_col) * (col - center_col));
                float norm_dist = dist / max_dist;

                // LEDs closer to center light up earlier
                float val = (progress * 1.8f) - norm_dist;

                uint8_t r_out = 0, g_out = 0, b_out = 0;

                if (val > 0.0f) {
                  if (val > 1.0f) val = 1.0f;

                  if (val < 0.33f) {
                    // Dark red phase
                    float p = val / 0.33f;
                    r_out = (uint8_t)(40 + 215 * p);
                    g_out = 0;
                    b_out = 0;
                  } else if (val < 0.66f) {
                    // Red to orange phase
                    float p = (val - 0.33f) / 0.33f;
                    r_out = 255;
                    g_out = (uint8_t)(140 * p);
                    b_out = 0;
                  } else {
                    // Orange to warm white phase
                    float p = (val - 0.66f) / 0.34f;
                    r_out = 255;
                    g_out = (uint8_t)(140 + 80 * p);
                    b_out = (uint8_t)(80 * p);
                  }
                }

                it[grid[row][col]] = Color(r_out, g_out, b_out);
              }
            }

      - addressable_lambda:
          name: "Wave"
          update_interval: 55ms
          lambda: |-
            // Traveling brightness wave sweeping across grid columns
            // Grid map: grid[row][col] = LED index
            static const int grid[4][4] = {
              { 0,  1,  2,  3},
              { 7,  6,  5,  4},
              { 8,  9, 10, 11},
              {15, 14, 13, 12}
            };

            static float wave_pos = 0.0;
            const float wave_speed = 0.15;
            const float wave_width = 3.0;  // Width in columns

            wave_pos += wave_speed;
            if (wave_pos > 4.0 + wave_width) {
              wave_pos = -wave_width;
            }

            for (int row = 0; row < 4; row++) {
              for (int col = 0; col < 4; col++) {
                float dist = fabs((float)col - wave_pos);
                float brightness = 0.0;
                if (dist < wave_width) {
                  brightness = 1.0 - (dist / wave_width);
                  // Smooth falloff
                  brightness = brightness * brightness;
                }

                it[grid[row][col]] = Color(
                  (uint8_t)(current_color.r * brightness),
                  (uint8_t)(current_color.g * brightness),
                  (uint8_t)(current_color.b * brightness)
                );
              }
            }

      - addressable_lambda:
          name: "Wave Fade"
          update_interval: 55ms
          lambda: |-
            // Symmetric fade wave sweeping across grid columns
            // Softer "hump" shape with fade on both sides
            static const int grid[4][4] = {
              { 0,  1,  2,  3},
              { 7,  6,  5,  4},
              { 8,  9, 10, 11},
              {15, 14, 13, 12}
            };

            static float wave_pos = 0.0;
            const float wave_speed = 0.12;
            const float wave_width = 2.5;

            wave_pos += wave_speed;
            if (wave_pos > 4.0 + wave_width) {
              wave_pos = -wave_width;
            }

            for (int row = 0; row < 4; row++) {
              for (int col = 0; col < 4; col++) {
                float dist = fabs((float)col - wave_pos);
                float brightness = 0.0;
                if (dist < wave_width) {
                  // Smooth bell curve shape
                  float t = dist / wave_width;
                  brightness = (1.0 - t) * (1.0 - t) * (1.0 + 2.0 * t);
                }

                it[grid[row][col]] = Color(
                  (uint8_t)(current_color.r * brightness),
                  (uint8_t)(current_color.g * brightness),
                  (uint8_t)(current_color.b * brightness)
                );
              }
            }

      - addressable_lambda:
          name: "Wave Comp"
          update_interval: 65ms
          lambda: |-
            // Dual counter-traveling waves in complementary colors
            // Sweeps across grid columns in opposite directions
            static const int grid[4][4] = {
              { 0,  1,  2,  3},
              { 7,  6,  5,  4},
              { 8,  9, 10, 11},
              {15, 14, 13, 12}
            };

            static float wave_pos = 0.0;
            const float wave_speed = 0.12;
            const float wave_width = 2.5;

            wave_pos += wave_speed;
            if (wave_pos > 4.0 + wave_width) {
              wave_pos = -wave_width;
            }

            // Complementary color (inverted)
            uint8_t comp_r = 255 - current_color.r;
            uint8_t comp_g = 255 - current_color.g;
            uint8_t comp_b = 255 - current_color.b;

            for (int row = 0; row < 4; row++) {
              for (int col = 0; col < 4; col++) {
                // Forward wave (left to right)
                float fwd_dist = fabs((float)col - wave_pos);
                float fwd_bright = 0.0;
                if (fwd_dist < wave_width) {
                  float t = fwd_dist / wave_width;
                  fwd_bright = (1.0 - t) * (1.0 - t);
                }

                // Backward wave (right to left)
                float bwd_col = 3.0 - wave_pos + 1.5;
                if (bwd_col < -wave_width) bwd_col += 4.0 + wave_width * 2;
                float bwd_dist = fabs((float)col - bwd_col);
                float bwd_bright = 0.0;
                if (bwd_dist < wave_width) {
                  float t = bwd_dist / wave_width;
                  bwd_bright = (1.0 - t) * (1.0 - t);
                }

                uint8_t r = std::min(255, (int)(current_color.r * fwd_bright + comp_r * bwd_bright));
                uint8_t g = std::min(255, (int)(current_color.g * fwd_bright + comp_g * bwd_bright));
                uint8_t b = std::min(255, (int)(current_color.b * fwd_bright + comp_b * bwd_bright));

                it[grid[row][col]] = Color(r, g, b);
              }
            }
