# Made for ESPHome compliant configuration
# Flux Night Light - 16 LED NeoPixel Ring

substitutions:
  name: "flux-night-light"
  friendly_name: "Flux Night Light"
  software_version: "1.1.2"

packages:
  custom_effects: !include effects.yaml

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true
  project:
    name: "flux_open_home.night_light"
    version: "${software_version}"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          // Global is available immediately from NVS — no delay needed.
          if (!id(power_restore_off)) {
            // User chose "Turn On" — turn on the light.
            // on_turn_on will handle restoring effect/color/brightness.
            auto call = id(led_array).make_call();
            call.set_state(true);
            call.perform();
          }
      - delay: 10s
      - lambda: |-
          // Mark boot complete after 10s. This gives enough time for
          // HA API to reconnect and attempt (and fail) to restore state
          // when "Stay Off" is selected. After this, user can freely
          // control the light from HA.
          id(boot_complete) = true;

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: "y"
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: "y"
      CONFIG_HTTP_BUF_SIZE: "16384"
      CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: "y"

logger:
  id: logger_component

api:
  id: api_server

ota:
  - id: ota_component
    platform: esphome
  - id: ota_http_request
    platform: http_request

http_request:
  id: http_request_component
  buffer_size_rx: 8192
  buffer_size_tx: 4096
  follow_redirects: true
  timeout: 30s
  verify_ssl: true

update:
  - platform: http_request
    id: firmware_update
    name: "Firmware Update"
    source: https://raw.githubusercontent.com/FluxOpenHome/NightLight/main/manifest.json

dashboard_import:
  package_import_url: github://FluxOpenHome/NightLight/flux-night-light.yaml@main
  import_full_config: true

wifi:
  id: wifi_component
  ap:
    ssid: "${name}"

captive_portal:
  id: captive_portal_component

esp32_improv:
  id: esp32_improv_component
  authorizer: none

improv_serial:
  id: improv_serial_component
  next_url: http://{{ip_address}}

web_server:
  id: web_server_component
  port: 80

preferences:
  flash_write_interval: 5s

globals:
  - id: saved_effect_index
    type: int
    restore_value: yes
    initial_value: '0'
  - id: saved_red
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_green
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_blue
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_brightness
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: power_restore_off
    type: bool
    restore_value: yes
    initial_value: 'false'

binary_sensor:
  - platform: gpio
    id: programming_button
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 50ms
    on_click:
      min_length: 10000ms
      max_length: 30000ms
      then:
        # Flash LED array 3 times to indicate factory reset
        - light.turn_on:
            id: led_array
            brightness: 100%
            red: 1.0
            green: 0.0
            blue: 0.0
            effect: "None"
        - delay: 200ms
        - light.turn_off: led_array
        - delay: 200ms
        - light.turn_on:
            id: led_array
            brightness: 100%
            red: 1.0
            green: 0.0
            blue: 0.0
            effect: "None"
        - delay: 200ms
        - light.turn_off: led_array
        - delay: 200ms
        - light.turn_on:
            id: led_array
            brightness: 100%
            red: 1.0
            green: 0.0
            blue: 0.0
            effect: "None"
        - delay: 200ms
        - light.turn_off: led_array
        - delay: 500ms
        # Reset saved globals to defaults
        - lambda: |-
            id(saved_effect_index) = 0;
            id(saved_red) = 1.0;
            id(saved_green) = 1.0;
            id(saved_blue) = 1.0;
            id(saved_brightness) = 1.0;
            id(power_restore_off) = false;
            auto call = id(power_restore_select).make_call();
            call.set_option("Turn On");
            call.perform();
        # Factory reset (clears WiFi credentials and restarts)
        - button.press: factory_reset_button

button:
  - platform: restart
    id: restart_button
    name: "Restart"

  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"

sensor:
  - platform: uptime
    id: uptime_sensor
    name: "Uptime"

  - platform: wifi_signal
    id: wifi_signal_sensor
    name: "WiFi Signal"
    update_interval: 60s

text_sensor:
  - platform: version
    id: esphome_version
    name: "ESPHome Version"

  - platform: wifi_info
    ip_address:
      id: wifi_ip_address
      name: "IP Address"
    ssid:
      id: wifi_ssid_info
      name: "Connected SSID"

select:
  - platform: template
    id: power_restore_select
    name: "Power Restore Behavior"
    icon: "mdi:power-settings"
    options:
      - "Turn On"
      - "Stay Off"
    initial_option: "Turn On"
    optimistic: true
    restore_value: true
    on_value:
      - lambda: |-
          id(power_restore_off) = (x == "Stay Off");

light:
  - platform: esp32_rmt_led_strip
    id: led_array
    name: "LED Array"
    pin: GPIO10
    num_leds: 16
    rgb_order: GRB
    chipset: ws2812
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: 100ms
      - lambda: |-
          // If boot hasn't completed and "Stay Off" is selected, reject
          // any turn-on attempt (e.g., HA API restoring last known state).
          // boot_complete stays false the entire session when "Stay Off",
          // so this blocks ALL automatic turn-on attempts until the user
          // explicitly changes the select to "Turn On" (which sets
          // boot_complete = true via on_value).
          if (!id(boot_complete) && id(power_restore_off)) {
            auto off = id(led_array).make_call();
            off.set_state(false);
            off.perform();
            return;
          }
          // Restore saved color, brightness, and effect
          auto call = id(led_array).make_call();
          call.set_brightness(id(saved_brightness));
          call.set_rgb(id(saved_red), id(saved_green), id(saved_blue));
          int idx = id(saved_effect_index);
          switch (idx) {
            case 1: call.set_effect("Random"); break;
            case 2: call.set_effect("Strobe"); break;
            case 3: call.set_effect("Flicker"); break;
            case 4: call.set_effect("Addressable Rainbow"); break;
            case 5: call.set_effect("Addressable Color Wipe"); break;
            case 6: call.set_effect("Addressable Scan"); break;
            case 7: call.set_effect("Addressable Twinkle"); break;
            case 8: call.set_effect("Addressable Random Twinkle"); break;
            case 9: call.set_effect("Addressable Fireworks"); break;
            case 10: call.set_effect("Addressable Flicker"); break;
            case 11: call.set_effect("Pulse"); break;
            case 12: call.set_effect("Fire"); break;
            case 13: call.set_effect("Flux Logo"); break;
            case 14: call.set_effect("Gold Glitter"); break;
            case 15: call.set_effect("Lightning Storm"); break;
            case 16: call.set_effect("Sunrise"); break;
            case 17: call.set_effect("Wave"); break;
            case 18: call.set_effect("Wave Fade"); break;
            case 19: call.set_effect("Wave Comp"); break;
            default: break;
          }
          call.perform();
    on_state:
      - delay: 250ms
      - lambda: |-
          // 250ms delay ensures on_turn_on (100ms) has fully finished
          // restoring saved state before we save anything.
          // Only save state when the light is on.
          if (!id(led_array).remote_values.is_on()) return;

          // Save effect
          std::string effect = id(led_array).get_effect_name();
          int idx = 0;
          if (effect == "Random") idx = 1;
          else if (effect == "Strobe") idx = 2;
          else if (effect == "Flicker") idx = 3;
          else if (effect == "Addressable Rainbow") idx = 4;
          else if (effect == "Addressable Color Wipe") idx = 5;
          else if (effect == "Addressable Scan") idx = 6;
          else if (effect == "Addressable Twinkle") idx = 7;
          else if (effect == "Addressable Random Twinkle") idx = 8;
          else if (effect == "Addressable Fireworks") idx = 9;
          else if (effect == "Addressable Flicker") idx = 10;
          else if (effect == "Pulse") idx = 11;
          else if (effect == "Fire") idx = 12;
          else if (effect == "Flux Logo") idx = 13;
          else if (effect == "Gold Glitter") idx = 14;
          else if (effect == "Lightning Storm") idx = 15;
          else if (effect == "Sunrise") idx = 16;
          else if (effect == "Wave") idx = 17;
          else if (effect == "Wave Fade") idx = 18;
          else if (effect == "Wave Comp") idx = 19;
          id(saved_effect_index) = idx;
          // Save color and brightness from remote_values
          float r = id(led_array).remote_values.get_red();
          float g = id(led_array).remote_values.get_green();
          float b = id(led_array).remote_values.get_blue();
          float br = id(led_array).remote_values.get_brightness();
          id(saved_red) = r;
          id(saved_green) = g;
          id(saved_blue) = b;
          id(saved_brightness) = br;
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 2s
          update_interval: 2s
          min_brightness: 20%
          max_brightness: 100%
      - random:
          name: "Random"
          transition_length: 2.5s
          update_interval: 3s
      - strobe:
          name: "Strobe"
      - flicker:
          name: "Flicker"
          alpha: 95%
          intensity: 2.5%
      - addressable_rainbow:
          name: "Addressable Rainbow"
          speed: 10
          width: 50
      - addressable_color_wipe:
          name: "Addressable Color Wipe"
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
          name: "Addressable Scan"
          move_interval: 100ms
          scan_width: 1
      - addressable_twinkle:
          name: "Addressable Twinkle"
          twinkle_probability: 5%
          progress_interval: 4ms
      - addressable_random_twinkle:
          name: "Addressable Random Twinkle"
          twinkle_probability: 5%
          progress_interval: 32ms
      - addressable_fireworks:
          name: "Addressable Fireworks"
          spark_probability: 10%
          use_random_color: true
          fade_out_rate: 120
      - addressable_flicker:
          name: "Addressable Flicker"
          intensity: 15%
          update_interval: 16ms
