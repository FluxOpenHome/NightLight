# Made for ESPHome compliant configuration
# Flux Night Light - 16 LED NeoPixel Ring

substitutions:
  name: "flux-night-light"
  friendly_name: "Flux Night Light"
  software_version: "1.0.5"

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true
  project:
    name: "flux_open_home.night_light"
    version: "${software_version}"
  on_boot:
    priority: -100
    then:
      - lambda: |-
          auto call = id(led_array).turn_on();
          call.set_brightness(id(saved_brightness));
          call.set_rgb(id(saved_red), id(saved_green), id(saved_blue));
          int idx = id(saved_effect_index);
          switch (idx) {
            case 1: call.set_effect("Random"); break;
            case 2: call.set_effect("Strobe"); break;
            case 3: call.set_effect("Flicker"); break;
            case 4: call.set_effect("Addressable Rainbow"); break;
            case 5: call.set_effect("Addressable Color Wipe"); break;
            case 6: call.set_effect("Addressable Scan"); break;
            case 7: call.set_effect("Addressable Twinkle"); break;
            case 8: call.set_effect("Addressable Random Twinkle"); break;
            case 9: call.set_effect("Addressable Fireworks"); break;
            case 10: call.set_effect("Addressable Flicker"); break;
            case 11: call.set_effect("Pulse"); break;
            case 12: call.set_effect("Fire"); break;
            case 13: call.set_effect("Flux Logo"); break;
            default: call.set_effect("None"); break;
          }
          call.perform();

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: "y"
      CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: "y"
      CONFIG_HTTP_BUF_SIZE: "16384"
      CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: "y"

logger:
  id: logger_component

api:
  id: api_server

ota:
  - id: ota_component
    platform: esphome
  - id: ota_http_request
    platform: http_request

http_request:
  id: http_request_component
  buffer_size_rx: 8192
  buffer_size_tx: 4096
  follow_redirects: true
  timeout: 30s
  verify_ssl: true

update:
  - platform: http_request
    id: firmware_update
    name: "Firmware Update"
    source: https://raw.githubusercontent.com/FluxOpenHome/NightLight/main/manifest.json

dashboard_import:
  package_import_url: github://FluxOpenHome/NightLight/flux-night-light.yaml@main
  import_full_config: true

wifi:
  id: wifi_component
  ap:
    ssid: "${name}"
    password: "12345678"

captive_portal:
  id: captive_portal_component

esp32_improv:
  id: esp32_improv_component
  authorizer: none

improv_serial:
  id: improv_serial_component
  next_url: http://{{ip_address}}

web_server:
  id: web_server_component
  port: 80

globals:
  - id: saved_effect_index
    type: int
    restore_value: yes
    initial_value: '0'
  - id: saved_red
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_green
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_blue
    type: float
    restore_value: yes
    initial_value: '1.0'
  - id: saved_brightness
    type: float
    restore_value: yes
    initial_value: '1.0'

button:
  - platform: restart
    id: restart_button
    name: "Restart"

sensor:
  - platform: uptime
    id: uptime_sensor
    name: "Uptime"

  - platform: wifi_signal
    id: wifi_signal_sensor
    name: "WiFi Signal"
    update_interval: 60s

text_sensor:
  - platform: version
    id: esphome_version
    name: "ESPHome Version"

  - platform: wifi_info
    ip_address:
      id: wifi_ip_address
      name: "IP Address"
    ssid:
      id: wifi_ssid_info
      name: "Connected SSID"

light:
  - platform: esp32_rmt_led_strip
    id: led_array
    name: "LED Array"
    pin: GPIO10
    num_leds: 16
    rgb_order: GRB
    chipset: ws2812
    restore_mode: RESTORE_DEFAULT_ON
    on_state:
      - lambda: |-
          // Save effect
          std::string effect = id(led_array).get_effect_name();
          int idx = 0;
          if (effect == "Random") idx = 1;
          else if (effect == "Strobe") idx = 2;
          else if (effect == "Flicker") idx = 3;
          else if (effect == "Addressable Rainbow") idx = 4;
          else if (effect == "Addressable Color Wipe") idx = 5;
          else if (effect == "Addressable Scan") idx = 6;
          else if (effect == "Addressable Twinkle") idx = 7;
          else if (effect == "Addressable Random Twinkle") idx = 8;
          else if (effect == "Addressable Fireworks") idx = 9;
          else if (effect == "Addressable Flicker") idx = 10;
          else if (effect == "Pulse") idx = 11;
          else if (effect == "Fire") idx = 12;
          else if (effect == "Flux Logo") idx = 13;
          if (id(saved_effect_index) != idx) {
            id(saved_effect_index) = idx;
          }
          // Save color and brightness
          float r, g, b;
          id(led_array).current_values_as_rgb(&r, &g, &b);
          float br = id(led_array).current_values.get_brightness();
          if (id(saved_red) != r) id(saved_red) = r;
          if (id(saved_green) != g) id(saved_green) = g;
          if (id(saved_blue) != b) id(saved_blue) = b;
          if (id(saved_brightness) != br) id(saved_brightness) = br;
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 2s
          update_interval: 2s
          min_brightness: 20%
          max_brightness: 100%
      - random:
          name: "Random"
          transition_length: 2.5s
          update_interval: 3s
      - strobe:
          name: "Strobe"
      - flicker:
          name: "Flicker"
          alpha: 95%
          intensity: 2.5%
      - addressable_rainbow:
          name: "Addressable Rainbow"
          speed: 10
          width: 50
      - addressable_color_wipe:
          name: "Addressable Color Wipe"
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
          name: "Addressable Scan"
          move_interval: 100ms
          scan_width: 1
      - addressable_twinkle:
          name: "Addressable Twinkle"
          twinkle_probability: 5%
          progress_interval: 4ms
      - addressable_random_twinkle:
          name: "Addressable Random Twinkle"
          twinkle_probability: 5%
          progress_interval: 32ms
      - addressable_fireworks:
          name: "Addressable Fireworks"
          spark_probability: 10%
          use_random_color: true
          fade_out_rate: 120
      - addressable_flicker:
          name: "Addressable Flicker"
          intensity: 5%
          update_interval: 16ms
      - addressable_lambda:
          name: "Fire"
          update_interval: 30ms
          lambda: |-
            // Helper: random int in [min, max)
            auto rng = [](int mn, int mx) -> int {
              return mn + (int)(esp_random() % (uint32_t)(mx - mn));
            };
            static uint8_t heat[16] = {};
            // Cool down each cell
            for (int i = 0; i < it.size(); i++) {
              int cooldown = rng(0, 40);
              heat[i] = (cooldown >= heat[i]) ? 0 : heat[i] - cooldown;
            }
            // Heat diffuses upward
            for (int i = it.size() - 1; i >= 2; i--) {
              heat[i] = (heat[i - 1] + heat[i - 2] + heat[i - 2]) / 3;
            }
            // Random sparks near the base
            if (rng(0, 255) < 120) {
              int pos = rng(0, 3);
              int val = heat[pos] + rng(160, 255);
              heat[pos] = (val > 255) ? 255 : val;
            }
            // Map heat to color (black -> red -> orange -> yellow -> white)
            for (int i = 0; i < it.size(); i++) {
              uint8_t t = heat[i];
              uint8_t r = 0, g = 0, b = 0;
              if (t > 0) {
                if (t <= 85) {
                  r = t * 3;
                } else if (t <= 170) {
                  r = 255;
                  g = (t - 85) * 3;
                } else {
                  r = 255;
                  g = 255;
                  b = (t - 170) * 3;
                }
              }
              it[i] = Color(r, g, b);
            }
      - addressable_lambda:
          name: "Flux Logo"
          update_interval: 50ms
          lambda: |-
            // Flux logo on 4x4 snake grid
            // LED layout (snake pattern):
            //   Row 4: 16 15 14 13   (right to left)
            //   Row 3:  9 10 11 12   (left to right)
            //   Row 2:  8  7  6  5   (right to left)
            //   Row 1:  1  2  3  4   (left to right)
            // Logo pixels (1-indexed): 1, 2, 3, 4, 6, 7, 10, 11, 13, 16
            static const int logo[] = {0, 1, 3, 5, 6, 9, 10, 12, 15};  // 0-indexed
            static const int logo_size = 10;
            static int step = 0;
            static bool drawing = true;

            it.all() = Color(0, 0, 0);

            if (drawing) {
              // Draw LEDs one at a time
              int show = std::min(step + 1, logo_size);
              for (int i = 0; i < show; i++) {
                it[logo[i]] = current_color;
              }
              step++;
              if (step >= logo_size + 30) {  // Hold for 30 frames after complete
                drawing = false;
                step = 0;
              }
            } else {
              // Fade out
              float fade = 1.0 - ((float)step / 20.0);
              if (fade < 0) fade = 0;
              for (int i = 0; i < logo_size; i++) {
                it[logo[i]] = Color(
                  current_color.r * fade,
                  current_color.g * fade,
                  current_color.b * fade
                );
              }
              step++;
              if (step >= 25) {  // Pause in darkness then restart
                drawing = true;
                step = 0;
              }
            }
